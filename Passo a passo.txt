308 - Criação do Projeto

- Em File, New , Spring Starter Project
- Colocar nome do projeto, versao do java, tipo(maven) e etc e avançar
- Proxima janela é para escolher as dependencias basicas do projeto
- Escolher Spring Web e avançar

- Salvar o Projeto no GitHub
- Abrir um terminal do GitHub na pasta local do projeto
- Configurar o usuario e email localmente.
git config --global user.name "Eduardo B"
git config --global user.email "eduardo.ads1814@gmail.com"
git add .
git commit -m "Project Created"
- Agora salvar o projeto no GitHub
- Criar o projeto sem GitIgnore
- Copiar o git remote e colar no terminarl
- Fazer o git push


309 - Criar a Entidade User (primeira do projeto) 
      Criar também nosso primeiro Resource (recurso WEB correspondente a Entidade User), este recurso vai disponibilzar dois end points para recuperarmos os usuarios cadastrados e também o usuario informando ID dele.

- Criar a Entidade User
	Implementar os atributos básicos
	Implementar as associações (ainda é a primeira entidade, entao nao tem)
	Construtores (é obrigado colocar o contrutor vazio) e instancia-las.
	Getters & Setters
	Implementar o hashCode & equals (por padrão, estamos colocando apenas o Id)
	Serializible (serve para quando vc quer que seus objetos possao sem transformados em cadeias de Bytes. Serve para que o objetro trafegue na rede, possa ser gravado em arquivo e assim por diante)

- Agora para testar se o nosso Rest da nossa aplicação Spring Boot está funcionando, vamos criar um Recurso básico baseado na nossa Clase User.
Para fazer isso, criar uma Classe chamada UserResource (esta classe vai disponibizar o recurso web correspondente a entidade User)	
Para falar que está classe é um recurso web que é implementado por um controlador Rest, precisa coolocar uma anotation no início. Depois dar um nome para o recurso.

- Criar um método para testar.
- Testar no navegador atraves do localhost:8080/users
- Fazer o git push

310 - Configuração do nosso Banco de Teste. Nosso banco de teste será o H2 que é muito utilizado em java para fazer testes na aplicação. É um banco de dados em memória.

- Implementar o banco no projeto.
- Criar um profile de testes que é um perfil do nosso projeto específico para fazer testes. (pode criar outros perfis de teste como desenvolvimento)

- Incluir no projeto as dependencias de JPA e H2    
- Copiar código das dependencias no material de apoio e colocar dento do arquivo pom.xml dentro de <dependecies></dependencies> . Com isso incluimos no projeto todas as bibliotecas do JPA e do H2.
- Configurar o arquivo application.properties que está em src/main/resources (copiar os codigos do material de apoio e colar la).   	
- Criar o arquivo application-test.properties em src/main/resources e o conteudo desse arquivo vai ter as configurações do nosso banco de dados H2 (banco de dados do perfil de teste). Pegar as configurações no material de apoio.

- Na nossa entidade (que por enquanto é apenas a clase User) , vamos colocar algumas anotations do JPA para instruir como que ele vai converter os objetos para o modelo relacional.

- No navegador, digitar http://localhost:8080/h2-console e conectar

Aula 311 - Implementar nosso primeiro repositorio utilizando o JPA repository, trabalhar com injeção de dependência automática feita pelo conteiner do framework e fazer nossa primeira instaciação do banco de dados (database seeding), vamos inserir alguns dados automaticamente no banco de dados.

- Criar o JPA repository. Criar a interface UserRepository que vai ser o responsável por operações com a entidade User. Para criar o UserRepository reutilizando o JPA repostiroy basta fazer ele estender o JPARepository passando o tipo da entidade que vc vai acessar mais o tipo da chave.

- Criar uma classe de configuração TestConfig para o perfil de teste que vai ser uma classe auxiliar que irá fazer algumas configurações na aplicação.

Aula 312 - Vamos implementar a nossa camada de serviço e aprender sobre Registro de Componentes (existente em todo framework que faz injeção de dependência)

- Criar a classe UserService (para assim fazer com que o Controlador SÓ dependa de serviço e o serviço SÓ dependa do repository) com duas operações básicas, que é a operação para buscar todos os usuários e a operação para buscar um usuário por ID. Para fazer isso a classe UserService precisa de uma dependência para UserRepository.

- Na classe UserResource (que é o controlador rest), criar a dependência para UserService e atualizar a implementação do findAll(). 

- Para a dependencia de UserService funcionar eu preciso registra-la como um componente. Colocar as anotations na classe.

- Na classe UserRepository não precisa colocar a anotation @Repository pois a mesma ja está herdando da classe extendida JpaRepository

- Abrir o PostMan, ir em My Workspace, abrir uma nova aba, colocar o metodo GET e digitar o endereço http://localhost:8080/users/

- Agora fazer o end point para buscar o usuario por ID
- Na classe UserService colocar a operação necessaria para isso.
- Na classe UserResource implementar o end point para buscar usuario por ID.

Aula 313 - Trabalhar com a classe de Pedido (Order), classe Instant (para representar um instante) e o padrão ISO 8601 (padrão para representar datas na forma de texto).

- A Classe Order é associada diretamente a clase User (um pedido tem usuario associado a ele e um User pode ter varios pedidos associados a ele). Nosso pedido vai ter o Id e moment (instante em que foi pedido).

- Criar a entidade Pedido (Classe Order) usando as mesmas regras da classe User

- Na classe Usuario criar a associação com a classe Order e instancia-la.
- Acrescentar o método Get para a lista.

- Voltar a classe Order
- Fazer as anotations necessárias do JPA na classe Order para dizer que esta classe é uma tabela do banco de dados.
- Implementar o relacionamento entre pedido (order) e cliente (user) para o JPA transformar isso em chaves estrangeiras no banco de dados.
- Necessário da outro nome para a nossa tabela no banco de dados (anotation @Table) e fazer o mesmo na classe User

- Na classe User vamos mapear o lado de um para muitos.

- Nesta aula criamos a tabela de pedidos e implementamos os mapeamentos de associação.

Aula 314 - Vamos falar da associação para muitos, lazy loading (carregamento tardio) e o JsonIgnore

- Criar repository da entidade Order (Interface OrderRepository)
- Criar o service da entidade Order  (Classe OrderService)
- Criar o resource da entidade Order (Classe Order_Resource)

- Na Classe TestConfig, vamos realizar o seed. Vamos mandar salvar alguns pedidos já na carga inicial do banco de dados.

- Colocar a anotation JasonIgnore para que o Banco de Dados não fique chamando infinitamente a tabela.

- Quando vc tem uma associação para muitos o JPA não carrega o os objetos do lado do muitos por padrão para não estourar a mamória do computador.

- Acrescentar anotation JasonIgnore na classe User

- Na classe Order, para garantir que o meu instant seja mostrado no Jason no formato de String do ISO 8601, colocar a @anotation @JsonFormat pra formatar o meu Json

Aula 315 - Vamos fazer um OrderStatus do tipo enumerado.

- Criar o enum OrderStatus
- Na instaciação a gente colocou o OrderStatus.PAID e assim por diante. Por padrão o java enumerao cada um dos tipos enumerados, se um programador simplesmente adicionar um ENUM no meio, ele quebra os valores banco de dados.
- Por isso temos que atribuir um valor numérico para cada tipo enumerado.

Aula 316 - Implementação da entidade Category usando as mesmas regras das Entidades anteriores

- Para ela ser uma entidade do meu sistema gerenciada pelo JPA, precisa fazer os anotations do JPA.

- Para acesar o banco de dados em relação as categorias, eu tenho que implementar a classe CategoryRepositore.
- Na classe TestConfig fazer a injeção de dependencia do CategoryRepository e depois instanciar no banco algumas categorias.

- Criar as classes CategoryResource e CategoryService
