308 - Criação do Projeto

- Em File, New , Spring Starter Project
- Colocar nome do projeto, versao do java, tipo(maven) e etc e avançar
- Proxima janela é para escolher as dependencias basicas do projeto
- Escolher Spring Web e avançar

- Salvar o Projeto no GitHub
- Abrir um terminal do GitHub na pasta local do projeto
- Configurar o usuario e email localmente.
git config --global user.name "Eduardo B"
git config --global user.email "eduardo.ads1814@gmail.com"
git add .
git commit -m "Project Created"
- Agora salvar o projeto no GitHub
- Criar o projeto sem GitIgnore
- Copiar o git remote e colar no terminarl
- Fazer o git push


309 - Criar a Entidade User (primeira do projeto) 
      Criar também nosso primeiro Resource (recurso WEB correspondente a Entidade User), este recurso vai disponibilzar dois end points para recuperarmos os usuarios cadastrados e também o usuario informando ID dele.

- Criar a Entidade User
	Implementar os atributos básicos
	Implementar as associações (ainda é a primeira entidade, entao nao tem)
	Construtores (é obrigado colocar o contrutor vazio) e instancia-las.
	Getters & Setters
	Implementar o hashCode & equals (por padrão, estamos colocando apenas o Id)
	Serializible (serve para quando vc quer que seus objetos possao sem transformados em cadeias de Bytes. Serve para que o objetro trafegue na rede, possa ser gravado em arquivo e assim por diante)

- Agora para testar se o nosso Rest da nossa aplicação Spring Boot está funcionando, vamos criar um Recurso básico baseado na nossa Clase User.
Para fazer isso, criar uma Classe chamada UserResource (esta classe vai disponibizar o recurso web correspondente a entidade User)	
Para falar que está classe é um recurso web que é implementado por um controlador Rest, precisa coolocar uma anotation no início. Depois dar um nome para o recurso.

- Criar um método para testar.
- Testar no navegador atraves do localhost:8080/users
- Fazer o git push

310 - Configuração do nosso Banco de Teste. Nosso banco de teste será o H2 que é muito utilizado em java para fazer testes na aplicação. É um banco de dados em memória.

- Implementar o banco no projeto.
- Criar um profile de testes que é um perfil do nosso projeto específico para fazer testes. (pode criar outros perfis de teste como desenvolvimento)

- Incluir no projeto as dependencias de JPA e H2    
- Copiar código das dependencias no material de apoio e colocar dento do arquivo pom.xml dentro de <dependecies></dependencies> . Com isso incluimos no projeto todas as bibliotecas do JPA e do H2.
- Configurar o arquivo application.properties que está em src/main/resources (copiar os codigos do material de apoio e colar la).   	
- Criar o arquivo application-test.properties em src/main/resources e o conteudo desse arquivo vai ter as configurações do nosso banco de dados H2 (banco de dados do perfil de teste). Pegar as configurações no material de apoio.

- Na nossa entidade (que por enquanto é apenas a clase User) , vamos colocar algumas anotations do JPA para instruir como que ele vai converter os objetos para o modelo relacional.

- No navegador, digitar http://localhost:8080/h2-console e conectar

Aula 311 - Implementar nosso primeiro repositorio utilizando o JPA repository, trabalhar com injeção de dependência automática feita pelo conteiner do framework e fazer nossa primeira instaciação do banco de dados (database seeding), vamos inserir alguns dados automaticamente no banco de dados.

- Criar o JPA repository. Criar a interface UserRepository que vai ser o responsável por operações com a entidade User. Para criar o UserRepository reutilizando o JPA repostiroy basta fazer ele estender o JPARepository passando o tipo da entidade que vc vai acessar mais o tipo da chave.

- Criar uma classe de configuração TestConfig para o perfil de teste que vai ser uma classe auxiliar que irá fazer algumas configurações na aplicação.

Aula 312 - Vamos implementar a nossa camada de serviço e aprender sobre Registro de Componentes (existente em todo framework que faz injeção de dependência)

- Criar a classe UserService (para assim fazer com que o Controlador SÓ dependa de serviço e o serviço SÓ dependa do repository) com duas operações básicas, que é a operação para buscar todos os usuários e a operação para buscar um usuário por ID. Para fazer isso a classe UserService precisa de uma dependência para UserRepository.

- Na classe UserResource (que é o controlador rest), criar a dependência para UserService e atualizar a implementação do findAll(). 

- Para a dependencia de UserService funcionar eu preciso registra-la como um componente. Colocar as anotations na classe.

- Na classe UserRepository não precisa colocar a anotation @Repository pois a mesma ja está herdando da classe extendida JpaRepository

- Abrir o PostMan, ir em My Workspace, abrir uma nova aba, colocar o metodo GET e digitar o endereço http://localhost:8080/users/

- Agora fazer o end point para buscar o usuario por ID
- Na classe UserService colocar a operação necessaria para isso.
- Na classe UserResource implementar o end point para buscar usuario por ID.

Aula 313 - Trabalhar com a classe de Pedido (Order), classe Instant (para representar um instante) e o padrão ISO 8601 (padrão para representar datas na forma de texto).

- A Classe Order é associada diretamente a clase User (um pedido tem usuario associado a ele e um User pode ter varios pedidos associados a ele). Nosso pedido vai ter o Id e moment (instante em que foi pedido).

- Criar a entidade Pedido (Classe Order) usando as mesmas regras da classe User

- Na classe Usuario criar a associação com a classe Order e instancia-la.
- Acrescentar o método Get para a lista.

- Voltar a classe Order
- Fazer as anotations necessárias do JPA na classe Order para dizer que esta classe é uma tabela do banco de dados.
- Implementar o relacionamento entre pedido (order) e cliente (user) para o JPA transformar isso em chaves estrangeiras no banco de dados.
- Necessário da outro nome para a nossa tabela no banco de dados (anotation @Table) e fazer o mesmo na classe User

- Na classe User vamos mapear o lado de um para muitos.

- Nesta aula criamos a tabela de pedidos e implementamos os mapeamentos de associação.

Aula 314 - Vamos falar da associação para muitos, lazy loading (carregamento tardio) e o JsonIgnore

- Criar repository da entidade Order (Interface OrderRepository)
- Criar o service da entidade Order  (Classe OrderService)
- Criar o resource da entidade Order (Classe Order_Resource)

- Na Classe TestConfig, vamos realizar o seed. Vamos mandar salvar alguns pedidos já na carga inicial do banco de dados.

- Colocar a anotation JasonIgnore para que o Banco de Dados não fique chamando infinitamente a tabela.

- Quando vc tem uma associação para muitos o JPA não carrega o os objetos do lado do muitos por padrão para não estourar a mamória do computador.

- Acrescentar anotation JasonIgnore sob List<Order> na classe User

- Na classe Order, para garantir que o meu instant seja mostrado no Jason no formato de String do ISO 8601, colocar a @anotation @JsonFormat pra formatar o meu Json

Aula 315 - Vamos fazer um OrderStatus do tipo enumerado.

- Criar o enum OrderStatus
- Na instaciação a gente colocou o OrderStatus.PAID e assim por diante. Por padrão o java enumerao cada um dos tipos enumerados, se um programador simplesmente adicionar um ENUM no meio, ele quebra os valores banco de dados.
- Por isso temos que atribuir um valor numérico para cada tipo enumerado.

Aula 316 - Implementação da entidade Category usando as mesmas regras das Entidades anteriores

- Para ela ser uma entidade do meu sistema gerenciada pelo JPA, precisa fazer os anotations do JPA.

- Para acesar o banco de dados em relação as categorias, eu tenho que criar a classe CategoryRepositore.
- Na classe TestConfig fazer a injeção de dependencia do CategoryRepository e depois instanciar no banco algumas categorias.

- Criar as classes CategoryResource e CategoryService

Aula 317 - Implementação da Entidade Produto

- Criar a classe Product utilizando as regras de entidade.
- Implementar as associações entre as classes Product e Category (dentro de Category eu vou ter um conjunto de Product e dentro de Product eu tenho um conjunto de Category)
- Como são coleções, usaremos apenas o Get
- De volta a classe Product, implementar o construtor padrão e depois o construtor com argumentos (retirar a coleção do construtor pois a mesma ja foi instanciada)
- Agora realizar o mapeamento objeto relacional do JPA (colocar as anotations).

- Criar a classe ProductRepository
- Na classe TestConfig fazer a injeção de dependencia do ProductRepository e depois instanciar no banco alguns produtos.
- Colocar a anotation @Transient de forma temporária


- Criar as classes ProductResource e ProductService

Aula 318 -  Associação muito para muitos com o JoinTable

- Um mesmo produto pode ter mais de uma categoria, assim como uma categoria pode ter mais de 1 produto.

- Vamos ter que mapear as classes Product e Category para que essa tabela de associação apareça lá no banco relacional.
- Na classe Product, apagar o 'Transeunt' (foi usado de forma temporária) e colocar o anotation @ManyToMany e @JoinTable e seus atributos
- Na classe Category colocar a referência para o mapeamento feito na classe Product 

- Baseado no fluxograma do projeto, associar os produtos com as categorias
- Na classe TestConfig, depois de instanciar as categorias, produtos e salvar, eu preciso dizer qual categoria de qual produto

- Para evitar o loop infinito no Postman, na classe Category adicionar a anotation @JsonIgnore

Aula 319 - Fazer o item de pedido (que terá uma associação com muito para muitos com atributos extras) - PARTE 1

- Criar uma classe auxiliar OrderItemPK - esta classe tem uma referência para as duas classes (pedido e produto)

- Criar a classe OrderItem

Aula 320 - Fazer o item de pedido (que terá uma associação com muito para muitos com atributos extras) - PARTE 2

- Na classe Order, fazer a associação OneToMany com a classe OrderItem
- Criar classe OrderItemRepository
- Na classe OrderItem colocar um @JsonIgnore em cima do método getOrder()
- Instanciar os itens de pedido na classe TestConfig

Aula 321 - Vamos fazer o Product-OrderItem associação muito para muitos (associação do produto com item de pedido)

- O Product tem uma associação direta com OrderItem que por sua vez tem associação com o Order.
- Como faremos para que a partir de um Product pegar uma lista de Orders associado a ele? Vamos ter que varrer a coleção de OrderItem associado a ele e para cada OrderItem vamos associar o objeto Order associado a OrderItem.

- Na classe Product fazer a associação (inversa) com OrderItem
- Na classe Product criar o método getOrders() para que ele responda uma lista de Order (e não OrderItem)
- Na classe Product colocar a anotation @JsonIgnore sobre getOrders()

Aula 322 - Fazer a entidade Pagamento e a associação um para um

- O Pagamento está associado com pedido.
- Um pedido de 0 ou 1 pagamento. E o pagamento por sua vez ele necessariamente tem 1 pedido.

- Criar a classe entidade Payment e fazer o check list necessario (atributos, associações, get and setters, constructors, hashcode e serializible)
- Fazer as anotations para o mapeamento do JPA
- Colocar o JsonIgnore sobre o atributo pedido(order)

- Na classe Order informar que um pedido de tem um pagamento também e incluir os getters and setters.
- Fazer as anotations para o mapeamento do JPA

- Na classe TestConfig inserir um pagamento. No pedidod Order o1 já ocorreu um pagamento ("OrderStatus.PAID"), então vamos colocar um pagamento para ele.
- Para colocar o pagamento precisa coloca objeto do tipo Paymento pay1


Aula 323 - Para fechar a implementação básica do modelo de dominio, faremos os métodos Subtotal() e Total()

- Na classe OrderItem, criar a função getSubtotal()

- Na classe Order(pedido) criar a função Total()

Aula 324 - Inserção de Usuário

- Na classe UserService, criar uma operação insert() para salvar no Banco de Dados os dados de um usuário

- Na classe UserResource fazer o endpoint para inserir criando o método ResponseEntity<User> insert(@RequestBody User obj).

- Ir no postman , trocar o get para 'post' , ir na aba body e colar os dados do usuario.

Aula 325 - Deletar um usuário

- Na classe UserService, fazer a deleção do usuário.

- Na classe UserResource, incluir o endpoint para deletar 

- Ir no postman , trocar o método 'delete' .

Aula 326 - Atualização de Usuário

- Na classe UserService, criar a função para atualizar um usuário.

- Na clsse UserResource, incluir o end point para atualizar